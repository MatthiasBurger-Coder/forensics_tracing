# Forensics Tracing BTM Generator

This repository hosts the `de.burger.forensics.btmgen` Gradle plugin. The plugin analyses Kotlin (and optionally simple Java) sources and produces Byteman rules that capture forensic traces of call-chains, decision points, and configured variable writes. The generated Byteman script can be injected into a JVM to obtain a "glass trail" of how a function executed across the codebase.

## Features

- Generates `AT ENTRY` / `AT EXIT` rules for functions and methods to trace call-chains.
- Adds decision tracing for `if`, `when`, and `is` expressions, including true/false branches.
- Emits `AFTER WRITE` rules for user-selected local variables.
- Provides an opt-in naive Java parser for additional coverage.
- Uses Kotlin PSI via `kotlin-compiler-embeddable`, no IDE dependencies required.

## Getting Started

1) Apply the plugin in your build.gradle.kts

```kotlin
plugins {
    id("de.burger.forensics.btmgen") version "1.0.0" // use the latest published version
}

repositories { mavenCentral() }
```

2) Optionally configure global defaults via the extension (used for convenience and backwards-compatibility)

```kotlin
forensicsBtmGen {
    // Defaults used by your project; task configuration (next step) is what actually runs
    srcDirs.set(listOf("src/main/kotlin"))
    pkgPrefix.set("") // legacy single prefix; prefer pkgPrefixes below
    pkgPrefixes.set(listOf("de.shop.app"))
    helperFqn.set("de.burger.forensics.ForensicsHelper")
    entryExit.set(true)
    trackedVars.set(listOf("approved", "status"))
    includeJava.set(false) // set to true to include naive Java parser
}
```

3) Register the generator task (the plugin does not auto-register tasks)

```kotlin
// Creates the task you will run. You can hard-code values here or read from the extension above.
tasks.register<de.burger.forensics.plugin.GenerateBtmTask>("generateBtmRules") {
    // Minimal, pragmatic configuration
    srcDirs.set(listOf("src/main/kotlin"))
    helperFqn.set("de.burger.forensics.ForensicsHelper")
    entryExit.set(true)
    trackedVars.set(listOf("approved", "status"))
    includeJava.set(false)
    // Optional knobs
    includeTimestamp.set(false)
    maxStringLength.set(0)
    pkgPrefixes.set(listOf("de.shop.app")) // preferred over single packagePrefix
    includePatterns.set(emptyList())
    excludePatterns.set(emptyList())
    parallelism.set(Runtime.getRuntime().availableProcessors().coerceAtLeast(1))
    shards.set(Runtime.getRuntime().availableProcessors().coerceAtLeast(1))
    gzipOutput.set(false)
    filePrefix.set("tracing-")
    rotateMaxBytesPerFile.set(4L * 1024 * 1024)
    rotateIntervalSeconds.set(0)
    flushThresholdBytes.set(64 * 1024)
    flushIntervalMillis.set(2000)
    writerThreadSafe.set(false)
    minBranchesPerMethod.set(0)
    safeMode.set(false)
    forceHelperForWhitelist.set(false)
    maxFileBytes.set(2_000_000)
    useAstScanner.set(true)
    outputDir.set(layout.buildDirectory.dir("forensics"))
}
```

4) Run the generator to produce Byteman rules in sharded files such as build/forensics/tracing-0001-00001.btm

```bash
./gradlew generateBtmRules
```

## Generated Rule Highlights

- **Call Chain:** Every selected function produces paired `enter` and `exit` helper calls, revealing the invocation order.
- **Decisions:** Conditions are logged with `iff`, `sw`, and `kase` helper calls for `if`/`when`/`is` constructs. Each rule preserves the original line number to keep the trace mappable to source.
- **Variable Writes:** Configure `trackedVars` to capture value flips with `writeVar` rules.

### Example Bootstrap Snippet

```byteman
RULE bootstrap@Forensics
CLASS *
METHOD *
HELPER de.burger.forensics.ForensicsHelper
AT ENTRY
IF true
DO startTrace("/var/log/forensics.log"), setQuota(5000), enableSampling(10)
ENDRULE

RULE shutdown@Forensics
CLASS *
METHOD *
HELPER de.burger.forensics.ForensicsHelper
AT EXIT
IF true
DO stopTrace()
ENDRULE
```

## Kotlin Specifics

- Top-level functions appear under the synthetic `<FileName>Kt` class, matching Kotlin's JVM naming conventions.
- Nested classes and objects translate to JVM binary names using `$` separators.
- Property writes use the generated setter (`setX`) methods; configure `trackedVars` to observe local variable assignments.
- Inline and suspend functions follow the standard Kotlin compilation model; the plugin operates on the PSI and preserves their logical structure.

## Continuous Delivery

Publishing to the Gradle Plugin Portal and Maven Central is ready via GitHub Actions (see `.github/workflows/release.yml`). Provide the required credentials as repository secrets to enable automated releases when tagging versions (`v*`).

For more details on Byteman, visit [https://byteman.jboss.org/](https://byteman.jboss.org/).

# Forensics Tracing BTM Generator

This repository hosts the `de.burger.forensics.btmgen` Gradle plugin. The plugin analyses Kotlin (and optionally simple Java) sources and produces Byteman rules that capture forensic traces of call-chains, decision points, and configured variable writes. The generated Byteman script can be injected into a JVM to obtain a "glass trail" of how a function executed across the codebase.

## Features

- Generates `AT ENTRY` / `AT EXIT` rules for functions and methods to trace call-chains.
- Adds decision tracing for `if`, `when`, and `is` expressions, including true/false branches.
- Emits `AFTER WRITE` rules for user-selected local variables.
- Provides an opt-in naive Java parser for additional coverage.
- Uses Kotlin PSI via `kotlin-compiler-embeddable`, no IDE dependencies required.

## Getting Started

1) Apply the plugin in your build.gradle.kts

```kotlin
plugins {
    id("de.burger.forensics.btmgen") version "1.0.0" // use the latest published version
}

repositories { mavenCentral() }
```

2) Optionally configure global defaults via the extension (used for convenience and backwards-compatibility)

```kotlin
forensicsBtmGen {
    // Defaults used by your project; task configuration (next step) is what actually runs
    srcDirs.set(listOf("src/main/kotlin"))
    pkgPrefix.set("") // legacy single prefix; prefer pkgPrefixes below
    pkgPrefixes.set(listOf("de.shop.app"))
    helperFqn.set("de.burger.forensics.ForensicsHelper")
    entryExit.set(true)
    trackedVars.set(listOf("approved", "status"))
    includeJava.set(false) // set to true to include naive Java parser
}
```

3) Register the generator task (the plugin does not auto-register tasks)

```kotlin
// Creates the task you will run. You can hard-code values here or read from the extension above.
tasks.register<de.burger.forensics.plugin.GenerateBtmTask>("generateBtmRules") {
    // Minimal, pragmatic configuration
    srcDirs.set(listOf("src/main/kotlin"))
    helperFqn.set("de.burger.forensics.ForensicsHelper")
    entryExit.set(true)
    trackedVars.set(listOf("approved", "status"))
    includeJava.set(false)
    // Prefer pkgPrefixes over legacy single-prefix properties
    pkgPrefixes.set(listOf("de.shop.app"))
    // Optional knobs
    includeTimestamp.set(false)
    maxStringLength.set(0)
    includePatterns.set(emptyList())
    excludePatterns.set(emptyList())
    parallelism.set(Runtime.getRuntime().availableProcessors().coerceAtLeast(1))
    shards.set(Runtime.getRuntime().availableProcessors().coerceAtLeast(1))
    gzipOutput.set(false)
    filePrefix.set("tracing-")
    rotateMaxBytesPerFile.set(4L * 1024 * 1024)
    rotateIntervalSeconds.set(0)
    flushThresholdBytes.set(64 * 1024)
    flushIntervalMillis.set(2000)
    writerThreadSafe.set(false)
    minBranchesPerMethod.set(0)
    safeMode.set(false)
    forceHelperForWhitelist.set(false)
    maxFileBytes.set(2_000_000)
    useAstScanner.set(true)
    outputDir.set(layout.buildDirectory.dir("forensics"))
}
```

4) Run the generator to produce Byteman rules in sharded files such as build/forensics/tracing-0001-00001.btm

```bash
./gradlew generateBtmRules
```

## Load the generated rules with Byteman

1) Start your target JVM with the Byteman agent listening on a port (example: 9091):

- Linux/macOS

```bash
java -javaagent:/path/to/byteman.jar=listener:true,port:9091 -jar app.jar
```

- Windows

```cmd
java -javaagent:C:\path\to\byteman.jar=listener:true,port:9091 -jar app.jar
```

2) Submit all generated .btm files:

- Linux/macOS

```bash
for f in build/forensics/*.btm; do
  bmsubmit -p 9091 -l "$f"
done
```

- Windows cmd

```cmd
for %f in (build\forensics\*.btm) do bmsubmit.bat -p 9091 -l "%f"
```

To unload later:

```bash
bmsubmit -p 9091 -u
```

## Generated Rule Highlights

- Call Chain: Every selected function produces paired `enter` and `exit` helper calls, revealing the invocation order.
- Decisions: Conditions are logged with `iff`, `sw`, and `kase` helper calls for `if`/`when`/`is` constructs. Each rule preserves the original line number to keep the trace mappable to source.
- Variable Writes: Configure `trackedVars` to capture value flips with `writeVar` rules.

### Example Bootstrap Snippet

```byteman
RULE bootstrap@Forensics
CLASS *
METHOD *
HELPER de.burger.forensics.ForensicsHelper
AT ENTRY
IF true
DO startTrace("/var/log/forensics.log"), setQuota(5000), enableSampling(10)
ENDRULE

RULE shutdown@Forensics
CLASS *
METHOD *
HELPER de.burger.forensics.ForensicsHelper
AT EXIT
IF true
DO stopTrace()
ENDRULE
```

## Kotlin Specifics

- Top-level functions appear under the synthetic `<FileName>Kt` class, matching Kotlin's JVM naming conventions.
- Nested classes and objects translate to JVM binary names using `$` separators.
- Property writes use the generated setter (`setX`) methods; configure `trackedVars` to observe local variable assignments.
- Inline and suspend functions follow the standard Kotlin compilation model; the plugin operates on the PSI and preserves their logical structure.

## Continuous Delivery

Publishing to the Gradle Plugin Portal and Maven Central is ready via GitHub Actions (see `.github/workflows/release.yml`). Provide the required credentials as repository secrets to enable automated releases when tagging versions (`v*`).

For more details on Byteman, visit [https://byteman.jboss.org/](https://byteman.jboss.org/).
